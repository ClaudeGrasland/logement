---
title: "Analyse spatiale du logement social en Ile de France"
subtitle: "Stage commun Carthageo-Geoprisme 2021"
date: "`r Sys.Date()`"
author: 
 - name: Claude Grasland
   affiliation: Université de Paris (Diderot)
image: "figures/citeverte.jpg"   
logo: "figures/citeverte.jpg"  
output:
  rzine::readrzine:
    highlight: kate
    number_sections: true
csl: Rzine_citation.csl
bibliography: biblio.bib
nocite: |
  @*
link-citations: true
#licence: "[![licensebuttons by-sa](https://licensebuttons.net/l/by-sa/3.0/88x31.png)](https://creativecommons.org/licenses/by-sa/4.0)"
#giturl: "[![Code source on GitHub](https://badgen.net/badge/Code%20source%20on%20/GitHub/blue?icon=github)](xxx)"
#doi: "[![DOI:xxx](https://zenodo.org/badge/DOI/xxx.svg)](https://doi.org/xxx)"
---

```{r setup, include=FALSE}

library(knitr)
library(rzine)
library(xtable)
library(survey)
library(knitr)
library(dplyr)
library(tidyr)
library(questionr)
library(sf)
library(ggplot2)

## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
	             cache=FALSE,
               prompt=FALSE,
               tidy=FALSE,
               comment=NA,
               message=FALSE,
               warning=FALSE,
               class.source="bg-info",
               class.output="bg-warning")

# opts_knit$set(width=75)
```



# Introduction {-}



# Données sociales


## Définir le sujet

Soit le sujet : *Logements sociaux et classes sociales dans le Val de Marne en 2017*

- **Définir les "logements sociaux"** : 
Logements HLM ? Logements SRU ?

- **Définir la notion de "classes sociales" ?** : 
Les CSP ? Un regroupement de CSP ? Les revenus ? la génération

- **Définir la date** :
Année 2017 uniquement ? Résultats du RP 2017 (2015-2019) ? 




## Formuler des questions ou des hypothèses

Qu'elles soient justes ou fausses, les hypothèses permettent de cadrer l'analyse.

- **CSP et logement social** : 
Les logements sociaux sont réservés aux CSP les plus modestes

-  **Âge et logement social** : 
Les logements sociaux sont réservés aux jeunes ménages actifs

-  **Logement social et territoire** : 
Les logements sociaux sont concentrés dans certains quartiers

-   **Logement social, âge et territoires** : 
Les personnes à la retraite quittent les logements sociaux.


## Organiser le travail 

Sutout dans le cadre d'un groupe !

- **Ne collecter que les données utiles pour répondre aux questions posées** afin de ne pas être tenté de partir dans toutes les directions

- **Archiver soigneusement les programmes et les résultats** afin de pouvoir reproduire ultérieurement les analyses sur une autre période, un autre territoire.

- **Ne pas attendre d'avoir accumulé tous les résultats pour les commenter¨** car l'analyse peut suggérer des erreurs ou ouvrir de nouvelles pistes.

- **Partir des questions et non pas des outils** faute de quoi on va trouver des réponses (42 ...) sans savoir quelle est la question. 


## Ne pas confondre les niveaux d'agrégation

Les réponses peuvent varier selon le niveau d'agrégation.

- **individu / groupe social** :
"Un ouvrier a plus de chance d'habiter en HLM qu'un cadre"

- **individu / groupe territorial** : 
"Les cadres et les ouvriers n'habitent pas dans les mêmes quartiers"

- **groupe social / groupe territorial** : 
"Les cadres évitent les quartiers où il y a beaucoup de logements sociaux"




## Charger les données statistiques


```{r, cache.comments=TRUE,comment=F,message=F, error=FALSE,echo=T}
tab_ind<-readRDS("data2021/94/indiv2017.RDS")

head(tab_ind[,1:5],2)
```


## Préparer l'analyse 


- Soit la relation entre logement en HLM (Y) et CSP du chef de ménage (X). Il s'agit de deux variables **catégorielles** (= qualitatives) que l'on va typiquement mettre en relation à l'aide d'un **tableau de contingence** et d'un **test du chi-2**. L'analyse statistique est simple sous R mais il faut tenir compte de trois difficultés

- Le choix de la **population de référence** est important 

- la sélection ou le regroupement  des **CSP** est également important car il va influer sur les résultats du test.

- la **pondération des individus** doit également être prise en compte puisque le recensement est basé sur un sondage


## Sélectionner les individus et les variables

Puisqu'on travaille sur les logements, on ne garde que les personnes de références des ménages (LPRM=1).


```{r, cache.comments=TRUE,comment=F,message=F, error=FALSE,echo=T}
#table(tab_ind$AGEMEN8)
tab_sel<- tab_ind %>% 
  filter(LPRM == 1) %>%
  select(CS1,HLML, IPONDI)

knitr::kable(head(tab_sel,4))
```

## Recoder les modalités

On cherche le code des modalités CS1 ezt HLML dans le fichier des métadonnées

```{r}
meta<-readRDS("data2021/94/indiv2017_meta.RDS")
metasel <- meta %>% filter(COD_VAR %in% c("CS1", "HLML"))
kable(metasel[,c(1,3,4)])
```


On recode les modalités des deux variables en regroupant certaines CSP


```{r, cache.comments=TRUE,comment=F,message=F, error=FALSE,echo=T}
tab_sel$HLML<-as.factor(tab_sel$HLML)
levels(tab_sel$HLML)<-c("HLM-O","HLM-N")
tab_sel$CS1<-as.factor(tab_sel$CS1)
levels(tab_sel$CS1) <- c("ARCAD","ARCAD","ARCAD","INTER",
                         "EMPOU","EMPOU","RETRA","INACT")

knitr::kable(head(tab_sel,3))
```

## Création du tableau de contingence non pondéré (FAUX)

La solution la plus simple semble être l'instruction *table()*


```{r, cache.comments=TRUE,comment=F,message=F, error=FALSE,echo=T}
tab_cont<-table(tab_sel$HLML,tab_sel$CS1)

knitr::kable(addmargins(tab_cont))
```


## Création du tableau de contingence pondéré (JUSTE)

On pondère avec *wtd.table()* du package *questionr*.


```{r, cache.comments=TRUE,comment=F,message=F, error=FALSE,echo=T}
library(questionr)
tab_cont_wtd<-wtd.table(tab_sel$HLML,tab_sel$CS1,
                        weights = tab_sel$IPONDI)

knitr::kable(round(addmargins(tab_cont_wtd),0))
```


## Analyser les profils 


- Tableau non pondéré ... légèrement faux !
```{r, cache.comments=TRUE,comment=F,message=F, error=FALSE,echo=F}
tab_pct<-cprop(tab_cont)
knitr::kable(tab_pct,digits=1)
```

- Tableau pondéré ... juste !
```{r, cache.comments=TRUE,comment=F,message=F, error=FALSE,echo=F}
tab_pct_wtd<-cprop(tab_cont_wtd)
knitr::kable(tab_pct_wtd,digits=1)
```


## Visualiser le tableau de contingence

On choisit l'orientation du tableau et on l'affiche avec plot()

```{r, cache.comments=TRUE,comment=F,message=F, comment = F,error=FALSE,echo=T,fig.height=6,fig.width=6 }

mytable<-wtd.table(tab_sel$CS1,tab_sel$HLML,weights = tab_sel$IPONDI)

plot(mytable, main = "Logements HLM par CSP", 
     sub = "Source : INSEE - RP 2017", 
     col=c("lightyellow","lightgreen"))
```

## Effectuer un test

Ce test se réalise facilement sur le tableau de contingence avec l'instruction *chisq.test()* :

```{r, cache.comments=TRUE,comment=F,message=F, comment = "",error=FALSE,echo=T}
mytest<-chisq.test(mytable)
mytest
```

## Visualisation des résidus

Lorsque la relation est significative, on visualise les cases les plus exceptionnelles avec *mosaicplot( ..., shade = T)*

```{r, cache.comments=TRUE,comment=F,message=F, comment = F,error=FALSE,echo=F, fig.height=4,fig.width=6}
mosaicplot(mytable, main =  "Logements HLM par CSP", sub = "Source : INSEE - RP 2017", shade =T)
```

## Conclusion

- **28% des ménages ordinaires du Val de Marne résident en HLM** : 
Ce chiffre ne tient toutefois pas compte de la **population concernée** qui peut être plus élevée.

- **La part du logement en HLM varie bien en fonction de la CSP des actifs** : 
44% des employés et ouvriers, 26% des intermédiaires, 11% des cadres. 

- **Les inactifs sont également nombreux en HLM** : 
33% d'entre eux sont dans ce cas, recouvrant des situations diverses.

- **Une partie des retraités demeurent en HLM** : 
Environ 25% d'entre eux.




# Données spatiales 

##  Le format sf (spatial features)

La cartographie et plus généralement les opérations géométriques sur des données spatiales dans R peuvent facilement être effectuées avec le **package sf** (spatial features) qui crée des objets uniques  rassemblant à la fois 

- un tableau de données (l'équivalent du fichier .dbf)
- une géométrie (l'équivalent du fichier .shp)
- une projection (l'équivalent du fichier .prj)

Lorsqu'on récupère des fonds de carte au format shapefile (.shp) ou dans d'autres formats standards comme GeoJson, la première tâche consiste donc à les convertir au formt sf afin de pouvoir les utiliser facilement dans R. L'importation se fait à l'aide de l'instruction `st_read` en indiquant juste le nom du fichier .shp à charger. Les autres fichiers (.dbf ou .proj) seront lus également et intégrés dans l'objet qui hérite de la double classe *data.frame* et *sf*.

##  Etapes de préparation des données

Dans notre exemple, nous allons suivre les étapes suivantes :

1. Préparer les données statistiques par IRIS dans un *data.frame*
2. Charger un fonds de carte par IRIS au format *sf*
3. Effectuer une jointure entre les deux fichiers par le code IRIS
4. Sauvegarder le résultat
5. Agréger les données statistiques et géométriques par commune
6. Sauvegarder le résultat.







## Préparer les données statistiques

On importe le fichier des individus :


```{r, cache.comments=TRUE,comment=F,message=F, error=FALSE,echo=T}
tab_ind<-readRDS("data2021/94/indiv2017.RDS")

head(tab_ind[,1:5],3)
```


##  Agréger les données 

On commence par créer un *tableau long* croisant les deux variables et leur effectif pondéré : 


```{r, cache.comments=TRUE,comment=F,message=F, error=FALSE,echo=T}
tab_long<- tab_ind %>%
           filter(LPRM == 1)%>%
           group_by(IRIS,HLML)%>%
           summarise(NB=sum(IPONDI))


knitr::kable(head(tab_long,5),digits=2)
```

##  Pivoter le tableau

Puis on fait "pivoter" le tableau pour l'obtenir en format large :

```{r, cache.comments=TRUE,comment=F,message=F, error=FALSE,echo=T}
tab_large <- tab_long %>% pivot_wider(id_cols = IRIS, 
                                      names_from = HLML,
                                      names_prefix = "HLM",
                                      values_from = NB,
                                      values_fill = 0)

knitr::kable(head(tab_large,5),digits=2)
```

## Ajouter de nouvelles variables

On ajoute de nouvelles variables telles que le nombre total de ménage et le % de ménages en HLM : 


```{r, cache.comments=TRUE,comment=F,message=F, error=FALSE,echo=T}
tab<- tab_large %>% mutate(TOT = HLM1+HLM2,
                           HLMpct = 100*HLM1/TOT)

knitr::kable(head(tab,5),digits=2)
```

## Examiner la distribution statistique 

On examine l'histogramme donnant distribution statistique du % de ménages ordinaires résidant en HLM par IRIS.


```{r, cache.comments=TRUE,comment=F,message=F, error=FALSE,echo=T}
p <- ggplot(tab) + aes (x = HLMpct) +
                   geom_histogram(breaks = c(0,10,20,30,40,50,
                                             60,70,80,90, 100)) +
                   scale_x_continuous("% de ménages en HLM") +
                   scale_y_continuous("Nombre d'IRIS") +
                   ggtitle(label = "Distribution des logements sociaux dans le Val de Marne",
                           subtitle = "Source : INSEE, RP 2017")
                            

p
```







## Charger les données géométriques

On importe le fichier des iris du Val-de-Marne qui est au format sf en ne gardant que les colonnes utiles


```{r,comment=F,message=F, error=FALSE, comments = F, echo=T}
map_iris <- readRDS("data2021/94/map_iris.RDS")
map_iris<-map_iris[,c(4,5,1,2,7)]
names(map_iris)<-c("IRIS","NOM_IRIS","COM","NOM_COM","geometry")

class(map_iris)
knitr::kable(head(as.data.frame(map_iris)[,1:4],2))
```


## Visualisation du fonds iris avec sf

On peut facilement produire une carte vierge des iris du Grand Paris en faisant un plot de la colonne *geometry* du fichier sf

```{r,comment=F,message=F, error=FALSE, comments = F, echo=T, fig.width=5, fig.height=4}
plot(map_iris$geometry,col="lightyellow")
```






## Jointure des données IRIS et du fonds de carte


```{r, cache.comments=TRUE,comment=F,message=F, error=FALSE,echo=T,warning=F}
map_iris_tab<-merge(map_iris,tab,
                   by.x="IRIS",by.y="IRIS",
                   all.x=T,all.y=F)

knitr::kable(head(map_iris_tab,3),digits=2)
```

## Sauvegarde du fichier par IRIS

On sauvegarde notre fichier au format .RDS de R 


```{r,comment=F,message=F, error=FALSE,echo=T,warning=F}
saveRDS(map_iris_tab,"data2021/94/map_iris_hlm.RDS")
```



## Agrégation statistique + géométriques

Grâce aux nouveaux packages de R (*dplyr* et *sf*) il est possible d'**agréger simultanément les statistiques et les géométries** après les avoir stockés dans un même objet de type "sf"

Du coup, on peut gagner beaucoup de temps dans les traitements et les analyses cartographiques, en particulier si l'on veut tester différents niveaux d'agrégation.


## Agrégation des IRIS en communes

L'agrégation est très facile et elle concerne à la fois les variables (de stock) et les geometries

### programme
```{r,comment=F,message=F, error=FALSE,echo=T,warning=F}
map_com_tab <- map_iris_tab %>% 
  group_by(COM, NOM_COM) %>% 
  summarise(HLM1=sum(HLM1,na.rm=T), 
            HLM2=sum(HLM2,na.rm=T)) %>%
  st_cast("MULTIPOLYGON")

map_com_tab <- map_com_tab %>%  mutate(TOT = HLM1+HLM2,
                                  HLMpct = 100*HLM1/TOT) 


knitr::kable(head(st_drop_geometry(map_com_tab),3),digits=2)
```

## Agrégation des iris en communes


```{r, cache.comments=TRUE,comment=F,message=F, error=FALSE,echo=F}
plot(map_com_tab$geometry,col ="lightyellow")
```

## Examiner la distribution statistique 

On examine l'histogramme donnant distribution statistique du % de ménages ordinaires résidant en HLM par Commune.

### programme
```{r, cache.comments=TRUE,comment=F,message=F, error=FALSE,echo=T}
p <- ggplot(map_com_tab) + aes (x = HLMpct) +
                   geom_histogram(breaks = c(0,10,20,30,40,50,
                                             60,70,80,90,100)) +
                   scale_x_continuous("% de ménages en HLM") +
                   scale_y_continuous("Nombre de communes") +
                   ggtitle(label = "Distribution des logements sociaux dans le Val de Marne",
                           subtitle = "Source : INSEE, RP 2017")
                            

p
```








## Sauvegarde du fichier par commune

On sauvegarde notre fichier au format .RDS de R 


```{r,comment=F,message=F, error=FALSE,echo=T,warning=F}
saveRDS(map_com_tab,"data2021/94/map_com_hlm.RDS")
```




# Bibliographie {-}

<div id="refs"></div>


# Annexes {-}


## Infos session  {-}

```{r session_info, echo=FALSE}
kableExtra::kable_styling(kable(sessionRzine()[[1]], row.names = F))
kableExtra::kable_styling(kable(sessionRzine()[[2]], row.names = F))
```



<br>


